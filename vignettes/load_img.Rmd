---
title: "Load_and_present_img"
output: rmarkdown::html_vignette
runtime: shiny
vignette: >
  %\VignetteIndexEntry{Load_and_present_img}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Stereology)
```

# Initial data loading and visualization

## Load image
```{r}
#file_path <- system.file("extdata", "sponge3.jpg", package = "Stereology")
#img <- load_img(file_path)
#class(img)
```
## Visualize
```{r}
# Plot
#p <- plot.stero(img)
#p
```

## Add grid
```{r}
#p <- add_grid(p)
#p
```
## Theoretic exploration of an image.

The functions 'bw_mat()' and 'th_i_est()' are meant to be used to give the user theoretic estimators based on an image.  <br/>
The function 'bw_mat()' takes two arguments the path where the image is stored and the threshold used for binary conversion. It returns a list with 2 elements. The first one is a matrix of 1s and 0s, which is generated by the given image. The second one is a plot of the black and white image, in order for the user to check if adjustments to the threshold are needed. 
The function 'th_i_est()' takes 6 arguments:  <br/>
- mtr: a matrix generated using the function 'bw_mat()'.
- x: the index of the pixel-row to start subsetting the 'mtr',
- y: the index of the pixel-column to start subsetting the 'mtr',
- dx: the length of pixels used to subset the 'mtr' on the x-axis,
- dy: The length of pixels used to subset the 'mtr' on the y-axis, and
- trial_s: The amount of repetitions used for the simulations. The Binomial distribution is used for the simulations. 

The function then outputs a list containing: <br/>

- submatrix: the part of the matrix we subsetted for,
- p: the probability estimated using this sub-matrix,
- mean_p_hat: the average of the p_hats generated through simulations, and
- variance_p_hat: the variance of those p_hats.

### Example of theoretical exploration of the image.

Below, there is an example of the functions 'bw_mat()' and 'th_i_est()' being used. <br/>
First, the image file to be used is loaded onto R, then the function bw_mat() is used. In this case, the  1s and 0s represent whether the area is 'filled' by sponge or not respectively.  As we can see a 1899 by 1266 matrix is generated. <br/>
After using the generated matrix ('a$matrix'), we make a submatrix by starting from pixel/entry (x=)400 traversing for a length(dx=) of 10 on the x-axis. For the y-axis we start from pixel/entry (y=)100 and traverse for a length(dy=) of 15. As a last argument in the function, we specify the trial size (trial_s) to be 10000. 

```{r}
# Loading the image.

# To use a PNG/JPEG/BMP image stored on your computer try:
# path <- "~/images.png"
path <- system.file('extdata/sponge3.jpg',package='Stereology')

# Applying bw_mat().
a <- bw_mat(path)
str(a)

# Image plot.
a$bw_image

# imsplit(path, "x", 10) %>% plot()

# Applying th_i_ests().
est_l <- th_i_ests(mtr = a$img_mat, x = 400, y = 100, dx= 10, dy = 15, trial_s = 10000)

# Print just mean_p_hat and variance_p_hat.
est_l$mean_p_hat
est_l$variance_p_hat
```



# Stereology

Let's try finding some points in a sponge
```{r}
ster()
```





