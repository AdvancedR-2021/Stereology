---
title: "Load_and_present_img"
output: rmarkdown::html_vignette
runtime: shiny
vignette: >
  %\VignetteIndexEntry{Load_and_present_img}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Stereology)
```


## Stereology

Let's try finding some points in a sponge
```{r}
line_estimator_app()
```


## Theoretic exploration of an image.

The functions 'bw_mat()' and 'th_i_est()' are meant to be used to give the user theoretic estimators based on an image.  <br/>
The function 'bw_mat()' takes two arguments the path where the image is stored and the threshold used for binary conversion. It returns a list with 2 elements. The first one is a matrix of 1s and 0s, which is generated by the given image. The second one is a plot of the black and white image, in order for the user to check if adjustments to the threshold are needed.   <br/>
  <br/>
The function 'th_i_est()' provides with estimates about the white portions of the image provided both 2 types of grid, the point grid and the line grid. It takes 5 arguments:  <br/>
- mtr: a matrix generated using the function 'bw_mat()'.
- x: the index of the pixel-row to start the grid,
- y: the index of the pixel-column to start the grid,
- lx: The amount of horizontal indices to be used, and
- ly: The amount of vertical indices to be used. <br/>

The function then outputs a list containing the estimators. <br/>


### Examples of theoretical exploration of images.

Below, there are two examples of the functions 'bw_mat()' and 'th_i_est()' being used. <br/>

#### Example A.

First, the image file to be used is loaded onto R, then the function bw_mat() is used and a 1899 by 1266 matrix is generated. In this case, the  1s and 0s represent whether the area is 'filled' by sponge or not respectively. In reference to the plot, the 1s represent the white area and the 0s the black one.<br/>
After using the generated matrix ('a$matrix'), we start from pixel/entry (x=)400 and create (lx=)5 points/lines on the horizontal direction. For the vertical direction, we start from pixel/entry (y=)100 and create (ly=)10 points/lines.

```{r}
# Loading the image.

# To use a PNG/JPEG/BMP image stored on your computer try:
# path <- "~/images.png"
path <- system.file('extdata/sponge3.jpg',package='Stereology')

# Applying bw_mat().
a <- bw_mat(path)
str(a)

# Applying th_i_ests().
est_a <- th_i_ests(mtr = a$img_mat, x = 400, y = 100, lx= 5, ly = 10)

# Print all different outputs.
est_a

```

#### Example B.

In this example, we focus our attention on the threshold.
We present the image under 3 different thresholds (0.75, 0.65 and 0.55 respectively) to highlight the fact that luminosity of the image plays an important part.
Then, we observe the difference of estimators for the same grid.

```{r}
# Loading the image.
path2 <- system.file('extdata/smallsponge.jpg',package='Stereology')

# Applying bw_mat().
b <- bw_mat(path2, 0.75)
d <- bw_mat(path2, 0.65)
e <- bw_mat(path2, 0.55)

# Image dimensions
dim(b$img_mat)

# Applying th_i_ests().
est_b <- th_i_ests(mtr = b$img_mat, x = 10, y = 20, lx= 5, ly = 5)
est_d <- th_i_ests(mtr = d$img_mat, x = 10, y = 20, lx= 5, ly = 5)
est_e <- th_i_ests(mtr = e$img_mat, x = 10, y = 20, lx= 5, ly = 5)

# Print just mean_p_hat and variance_p_hat.

tab <- matrix(c(est_b$point_mean, est_b$line_mean,
                est_d$point_mean, est_d$line_mean,
                est_e$point_mean, est_e$line_mean), 
              ncol=2, byrow=TRUE)
colnames(tab) <- c('Point Mean', 'Line Mean')
rownames(tab) <- c('b','d','e')
tab <- as.table(tab)
tab

# The only pore in "e".
e$img_mat[160:175, 255:267]
```






